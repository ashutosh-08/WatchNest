import fs from "fs/promises";
import os from "os";
import path from "path";
import { spawn } from "child_process";
import { Video } from "../models/video.model.js";
import { uploadOnCloudinary } from "../utils/cloudinary.js";

const STORYBOARD_JOB_PREFIX = "[storyboard]";
const THUMB_WIDTH = 160;
const THUMB_HEIGHT = 90;
const TILE_COLS = 10;
const TILE_ROWS = 10;
const THUMBS_PER_SPRITE = TILE_COLS * TILE_ROWS;
const activeJobs = new Set();

const isStoryboardEnabled = () => process.env.ENABLE_STORYBOARD === "true";

const pad = (num, len = 2) => String(num).padStart(len, "0");

const toVttTime = (secondsInput) => {
    const totalMs = Math.max(0, Math.floor((secondsInput || 0) * 1000));
    const hours = Math.floor(totalMs / 3600000);
    const minutes = Math.floor((totalMs % 3600000) / 60000);
    const seconds = Math.floor((totalMs % 60000) / 1000);
    const milliseconds = totalMs % 1000;
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}.${pad(milliseconds, 3)}`;
};

const runCommand = (command, args) =>
    new Promise((resolve, reject) => {
        const child = spawn(command, args, { stdio: ["ignore", "pipe", "pipe"] });
        let stderr = "";
        child.stderr.on("data", (chunk) => {
            stderr += chunk.toString();
        });
        child.on("error", reject);
        child.on("close", (code) => {
            if (code === 0) return resolve();
            reject(new Error(`${command} exited with code ${code}. ${stderr}`));
        });
    });

const ensureFfmpegAvailable = async () => {
    await runCommand("ffmpeg", ["-version"]);
};

const generateSpriteSheets = async ({ sourceVideoUrl, intervalSec, outputDir }) => {
    const outputPattern = path.join(outputDir, "sprite-%03d.jpg");
    await runCommand("ffmpeg", [
        "-y",
        "-i",
        sourceVideoUrl,
        "-vf",
        `fps=1/${intervalSec},scale=${THUMB_WIDTH}:${THUMB_HEIGHT},tile=${TILE_COLS}x${TILE_ROWS}`,
        "-q:v",
        "4",
        outputPattern,
    ]);

    const files = (await fs.readdir(outputDir))
        .filter((name) => /^sprite-\d{3}\.jpg$/i.test(name))
        .sort();

    if (files.length === 0) {
        throw new Error("No storyboard sprite sheets generated by ffmpeg");
    }

    return files.map((file) => path.join(outputDir, file));
};

const buildVtt = ({ durationSec, intervalSec, spriteUrls }) => {
    const safeDuration = Math.max(intervalSec, Math.ceil(durationSec || 0));
    const totalThumbs = Math.max(1, Math.ceil(safeDuration / intervalSec));
    const lines = ["WEBVTT", ""];

    for (let i = 0; i < totalThumbs; i += 1) {
        const start = i * intervalSec;
        const end = Math.min((i + 1) * intervalSec, safeDuration);
        const spriteIndex = Math.floor(i / THUMBS_PER_SPRITE);
        const cellIndex = i % THUMBS_PER_SPRITE;
        const x = (cellIndex % TILE_COLS) * THUMB_WIDTH;
        const y = Math.floor(cellIndex / TILE_COLS) * THUMB_HEIGHT;
        const spriteUrl = spriteUrls[spriteIndex] || spriteUrls[spriteUrls.length - 1];

        lines.push(`${toVttTime(start)} --> ${toVttTime(end)}`);
        lines.push(`${spriteUrl}#xywh=${x},${y},${THUMB_WIDTH},${THUMB_HEIGHT}`);
        lines.push("");
    }

    return lines.join("\n");
};

const processStoryboardJob = async ({ videoId, sourceVideoUrl, intervalSec = 5, durationSec = 0 }) => {
    const outputDir = await fs.mkdtemp(path.join(os.tmpdir(), `watchnest-storyboard-${videoId}-`));

    try {
        await ensureFfmpegAvailable();
        const spritePaths = await generateSpriteSheets({
            sourceVideoUrl,
            intervalSec,
            outputDir,
        });

        const spriteUrls = [];
        for (const spritePath of spritePaths) {
            const uploadedSprite = await uploadOnCloudinary(spritePath);
            if (!uploadedSprite?.secure_url && !uploadedSprite?.url) {
                throw new Error(`Sprite upload failed for ${path.basename(spritePath)}`);
            }
            spriteUrls.push(uploadedSprite.secure_url || uploadedSprite.url);
        }

        const vttContent = buildVtt({ durationSec, intervalSec, spriteUrls });
        const vttPath = path.join(outputDir, "storyboard.vtt");
        await fs.writeFile(vttPath, vttContent, "utf8");
        const uploadedVtt = await uploadOnCloudinary(vttPath);
        const vttUrl = uploadedVtt?.secure_url || uploadedVtt?.url;
        if (!vttUrl) {
            throw new Error("Storyboard VTT upload failed");
        }

        await Video.findByIdAndUpdate(videoId, {
            $set: {
                storyboardStatus: "ready",
                storyboardSpriteUrl: spriteUrls[0] || "",
                storyboardVttUrl: vttUrl,
                storyboardIntervalSec: intervalSec,
                storyboardThumbWidth: THUMB_WIDTH,
                storyboardThumbHeight: THUMB_HEIGHT,
            },
        });

        console.log(`${STORYBOARD_JOB_PREFIX} ready video=${videoId} sprites=${spriteUrls.length}`);
    } catch (error) {
        await Video.findByIdAndUpdate(videoId, {
            $set: {
                storyboardStatus: "failed",
                storyboardSpriteUrl: "",
                storyboardVttUrl: "",
            },
        });
        throw error;
    } finally {
        await fs.rm(outputDir, { recursive: true, force: true });
    }
};

const enqueueStoryboardGeneration = async ({
    videoId,
    sourceVideoUrl,
    intervalSec = 5,
    durationSec = 0,
}) => {
    if (!isStoryboardEnabled()) {
        return { accepted: false, reason: "feature_disabled" };
    }

    if (!videoId || !sourceVideoUrl) {
        return { accepted: false, reason: "invalid_payload" };
    }

    if (activeJobs.has(videoId)) {
        return { accepted: true, deduplicated: true };
    }

    activeJobs.add(videoId);
    setImmediate(async () => {
        try {
            console.log(`${STORYBOARD_JOB_PREFIX} queued video=${videoId} intervalSec=${intervalSec}`);
            await processStoryboardJob({
                videoId,
                sourceVideoUrl,
                intervalSec,
                durationSec,
            });
        } catch (error) {
            console.error(`${STORYBOARD_JOB_PREFIX} failed video=${videoId}`, error);
        } finally {
            activeJobs.delete(videoId);
        }
    });

    return { accepted: true };
};

export { enqueueStoryboardGeneration, isStoryboardEnabled };
